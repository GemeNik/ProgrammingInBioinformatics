{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Processing FASTA files\n",
    "\n",
    "Exercise for processing DNA sequences.\n",
    "\n",
    "* **Contact:** mate.balajti@unibas.ch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "filename1 = \"sequences.fasta\"\n",
    "filename2 = \"genome.fasta\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Exercise 1.1 (3 points)\n",
    "\n",
    "Write a function `parse_fasta()` that takes a path to a FASTA file as input\n",
    "and returns a tuple of two lists, the first containing sequence headers\n",
    "stripped of the leading `>`, and the second containing the actual sequences.\n",
    "\n",
    "> **Notes:**\n",
    ">  \n",
    "> * Please write the parser from scratch and do _not_ use existing FASTA\n",
    ">   parsers, such as the one provided by Biopython.\n",
    "> * Ensure that wrapped sequences are handled such that fragments of a given\n",
    ">   sequence are concatenated, without white space, in the order they appear\n",
    ">   in the file. Make use of the leading `>` character to separate records\n",
    ">   from each other.\n",
    "> * Ensure that the number of items in the returned lists correspond to the\n",
    ">   original number of records in the input file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "def parse_fasta(path: str) -> tuple[list[str], list[str]]:\n",
    "    headers = []\n",
    "    sequences = []\n",
    "    current_sequence = \"\"\n",
    "\n",
    "    with open(path, 'r') as fasta_file:\n",
    "        for line in fasta_file:\n",
    "            line = line.strip()\n",
    "            if line.startwith('>'):\n",
    "                if current_sequence:\n",
    "                    sequences.append(current_sequence)\n",
    "                    current_sequence = \"\"\n",
    "                headers.append(line[1:])\n",
    "            else:\n",
    "                current_sequence += line\n",
    "\n",
    "        if current_sequence:\n",
    "            sequences.append(current_sequence)\n",
    "\n",
    "\n",
    "    return headerss, sequence"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Exercise 1.2 (2 points)\n",
    "\n",
    "Write a function `discard_ambiguous_seqs()` that takes two arguments, a list of sequence headers and list of strings as input \n",
    "and returns a tuple of two lists with only those headers and strings that exclusively consist of letters of the\n",
    "\"DNA alphabet\" (`A`, `C`, `G`, `T`).\n",
    "\n",
    "> **Notes:**\n",
    ">  \n",
    "> * Make sure your implementation is case-insensitive, i.e., sequences\n",
    ">   containing lowercase DNA characters, even if mixed with uppercase\n",
    ">   characters, are valid as well."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "def discard_ambiguous_seqs(header: list[str], sequence: list[str]) -> \\\n",
    "  tuple[: list[str], : list[str]]:\n",
    "\n",
    "    l1_header = []\n",
    "    l2_sequence = []\n",
    "    DNA_alphabet = {\"A\", \"G\", \"C\", \"T\"}\n",
    "\n",
    "    for n, seq in zip(header, sequence):\n",
    "\n",
    "        if all(char.upper() in DNA_alphabet for char in seq):\n",
    "            l1_header.append(h)\n",
    "            l2_sequence.append(seq)\n",
    "    \n",
    "\n",
    "    return r_header, r_sequence"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Exercise 1.3 (2 points)\n",
    "\n",
    "Write a function `nucleotide_frequencies()` that takes a list of strings as\n",
    "input, and which prints out the total frequency of each nucleotide across\n",
    "all input sequences. Use the following example as a template to format your\n",
    "output:\n",
    "\n",
    "```console\n",
    "A: 0.31\n",
    "C: 0.21\n",
    "G: 0.17\n",
    "T: 0.31\n",
    "```\n",
    "\n",
    "> **Notes:**\n",
    ">\n",
    "> * Note how numbers are rounded in the example and format decimals printed\n",
    ">   by your solution in the same manner, i.e., rounded to two significant\n",
    ">   digits.\n",
    "> * The function does not require any specific return value. In case you are\n",
    ">   not aware of how Python deals with functions without an explicit `return`\n",
    ">   statement, look up the behavior in relevant documentation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def nucleotide_frequencies(seqs: list[str]) -> None:\n",
    "    # count nucleotides\n",
    "    nucleotides_count = {'A' : 0, 'C' : 0, 'G' : 0, 'T' : 0}\n",
    "    total = 0\n",
    "\n",
    "    for seq in sequences:\n",
    "        for nucleotide in seq.upper():\n",
    "            if nucleotide in nucleotides_count:\n",
    "                nucleotides_count[nucleotide] += 1\n",
    "                total += 1\n",
    "\n",
    "    if total > 0:\n",
    "        for nucleotide in nucleotides_count:\n",
    "            frequency = nucleotides_count[nucleotide] / total\n",
    "            print(f\"{nucleotide} : {frequency: .2f}\")\n",
    "\n",
    "    else:\n",
    "        print(\"No nucleotides\")\n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Exercise 1.4 (3 points)\n",
    "\n",
    "Write a function `map_reads()` that takes as input two FASTA files, the first\n",
    "containing short read sequences (\"query\"), and the second containing reference\n",
    "sequences. The function should \n",
    "* read the files, \n",
    "* discard _query_ sequences that contain non-DNA characters, \n",
    "* print the nucleotide fractions for both files to\n",
    "the console \n",
    "* and returns a dictionary of dictionaries, where the outer\n",
    "dictionary uses the names of query sequences as its keys, and the inner\n",
    "dictionary uses reference sequence names as keys and a list of 1-based indices\n",
    "indicating at which position (counting from left to right) in the reference\n",
    "sequence the query sequence occurs as an exact substring.\n",
    "\n",
    "Execute the function, passing `sequences.fasta` and `genome.fasta` as input.\n",
    "Inspect the returned \"hits\" object (the dictionary of dicionaries). Interpret\n",
    "the results in at least 2-3 bullet points. What's special about query sequence\n",
    "`sequence4`?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Query nucleotides frequency:\n",
      "A :  0.24\n",
      "C :  0.16\n",
      "G :  0.35\n",
      "T :  0.24\n",
      "Reference nucleotides frequency:\n",
      "A :  0.25\n",
      "C :  0.26\n",
      "G :  0.25\n",
      "T :  0.24\n",
      "Hits :\n",
      "sequence1: {}\n",
      "sequence2: {'chr2': [1422]}\n",
      "sequence4: {'chr2': [1039], 'chr3': [1422], 'chr4': [1455]}\n"
     ]
    }
   ],
   "source": [
    "def parse_fasta(path: str) -> tuple[list[str], list[str]]:\n",
    "    headers = []\n",
    "    sequences = []\n",
    "    current_sequence = \"\"\n",
    "\n",
    "    with open(path, 'r') as fasta_file:\n",
    "        for line in fasta_file:\n",
    "            line = line.strip()\n",
    "            if line.startswith('>'):\n",
    "                if current_sequence:\n",
    "                    sequences.append(current_sequence)\n",
    "                    current_sequence = \"\"\n",
    "                headers.append(line[1:])\n",
    "            else:\n",
    "                current_sequence += line\n",
    "\n",
    "        if current_sequence:\n",
    "            sequences.append(current_sequence)\n",
    "\n",
    "\n",
    "    return headers, sequences\n",
    "\n",
    "def discard_ambiguous_seqs(header: list[str], sequence: list[str]) -> \\\n",
    "  tuple[: list[str], : list[str]]:\n",
    "\n",
    "    l1_header = []\n",
    "    l2_sequence = []\n",
    "    DNA_alphabet = {\"A\", \"G\", \"C\", \"T\"}\n",
    "\n",
    "    for n, seq in zip(header, sequence):\n",
    "\n",
    "        if all(char.upper() in DNA_alphabet for char in seq):\n",
    "            l1_header.append(n)\n",
    "            l2_sequence.append(seq)\n",
    "    \n",
    "\n",
    "    return l1_header, l2_sequence\n",
    "\n",
    "def nucleotide_frequencies(seqs: list[str]) -> None:\n",
    "    # count nucleotides\n",
    "    nucleotides_count = {'A' : 0, 'C' : 0, 'G' : 0, 'T' : 0}\n",
    "    total = 0\n",
    "\n",
    "    for seq in seqs:\n",
    "        for nucleotide in seq.upper():\n",
    "            if nucleotide in nucleotides_count:\n",
    "                nucleotides_count[nucleotide] += 1\n",
    "                total += 1\n",
    "\n",
    "    if total > 0:\n",
    "        for nucleotide in nucleotides_count:\n",
    "            frequency = nucleotides_count[nucleotide] / total\n",
    "            print(f\"{nucleotide} : {frequency: .2f}\")\n",
    "\n",
    "    else:\n",
    "        print(\"No nucleotides\")\n",
    "\n",
    "\n",
    "def map_reads(filename1: str, filename2: str) -> dict[dict[str: list[int]]]:\n",
    "    query_headers, query_sequences = parse_fasta(filename1)\n",
    "    reference_headers, reference_sequences = parse_fasta(filename2)\n",
    "\n",
    "    query_headers, query_sequences = discard_ambiguous_seqs(query_headers, query_sequences)\n",
    "\n",
    "    print(\"Query nucleotides frequency:\")\n",
    "    nucleotide_frequencies(query_sequences)\n",
    "\n",
    "    print(\"Reference nucleotides frequency:\")\n",
    "    nucleotide_frequencies(reference_sequences)\n",
    "\n",
    "    results = {header: {} for header in query_headers}\n",
    "\n",
    "    for query_header, query_seq in zip (query_headers, query_sequences):\n",
    "        for ref_header, ref_seq in zip(reference_headers, reference_sequences):\n",
    "\n",
    "            start = 0\n",
    "            while True:\n",
    "                start = ref_seq.find(query_seq, start)\n",
    "                if start == -1:\n",
    "                    break\n",
    "                if ref_header not in results[query_header]:\n",
    "                    results[query_header][ref_header] = []\n",
    "                results[query_header][ref_header].append(start + 1)\n",
    "                start += 1\n",
    "\n",
    "    return results\n",
    "\n",
    "filename1 = \"sequences.fasta\"\n",
    "filename2 = \"genome.fasta\"\n",
    "\n",
    "hits = map_reads(filename1, filename2)\n",
    "\n",
    "print(\"Hits :\")\n",
    "for query, refs in hits.items():\n",
    "    print(f\"{query}: {refs}\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['sequence1', 'sequence2', 'sequence3', 'sequence4']\n",
      "['GAAGTTTACTAaCTGGAGTGGTCAGaAGTTGCCGCCTGTG', 'GCCCGGGCGTATGTATGAGAGATGTGGCCAGAAGTCGAAA', 'ATGATTDATGTGTCCGGTAACTATAAACGTGCTACGATGT', 'TTTGAG']\n"
     ]
    }
   ],
   "source": [
    "header_fasta, seq_fasta = parse_fasta(\"sequences.fasta\")\n",
    "print(header_fasta)\n",
    "print(seq_fasta)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
